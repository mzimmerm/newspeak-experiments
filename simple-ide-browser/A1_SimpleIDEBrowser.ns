Newspeak3
'Root'
class A1_SimpleIDEBrowser usingPlatform: platform <Platform> webIDE: ide <HopscotchWebIDE> 
  (* :exemplar:  A1_SimpleIDEBrowser usingPlatform: platform webIDE: ide. *)
  = (
	|
    (* imports *)
    List = platform collections List.    
	ClassMirror = platform mirrors ClassMirror.
	Presenter = platform hopscotch Presenter.
    Subject = platform hopscotch Subject.
    Exception = platform kernel Exception.
    
    (* slots *)
    ide = ide.
    classUIs <List[ClassUI]> (* todo : should this be ClassGroup? *)
	|
  ) (
public class ClassUI forClassDefinedBy: classOrClassDeclarationMirror <Behavior|ClassDeclarationMirror> = (
  	|
    (* Class is also Behavior *)
    (* public for accesibility to pass to nested ClassModel factory *)
    public classDeclarationMirror = classOrClassDeclarationMirror isKindOfClass 
    	ifTrue: [(ClassMirror reflecting: classOrClassDeclarationMirror) mixin declaration]
        ifFalse: [
        	classOrClassMirror isKindOfClassDeclarationMirror
            	ifTrue: [classOrClassDeclarationMirror]
                ifFalse: [break. Exception signal: 'Perhaps trying to pass aClassMirror? Pass aClassMirror declaration <ClassDeclarationMirror> instead.']
        ].
  
    (* todo Only need Subject. Can get presenter and view from it *)
    subject = ClassSubject onModel: (ClassModel forClassDeclaratioMirror: classDeclarationMirror).

	(* members used by multiple models in UI and it's nested classes *)
    (* todo-done private classDeclarationMirror = classMirror mixin declaration. *)
    
    (* instanceSide returns MixinMirror, which has API similar to ClassMirror, can get slots, nestedClasses, methods from it. TODO: WHY NOT classSide?? *)
    private nestedClassesGroup <MirrorGroup[ClassDeclarationMirror]> =  classDeclarationMirror instanceSide nestedClasses.
    private nestedClassDeclarationMirrors ::= nestedClassesGroup do: [:nestedClassDeclarationMirror | nestedClassDeclarationMirror].

    (* indented UIs *)
	factoryUI <FactoryUI> (* todo : this seems replaced with headingDefinition *)
    (* todo: finish: nestedClassesUIs <List[ClassUI]> ::= nestedClassDeclarationMirrors collect: [:nestedClassDeclarationMirror | ClassUI forClass: nestedClassDeclarationMirror klass]. *)
    nestedClassGroupUI <NestedClassGroupUI>
    instanceMethodGroupUI <MethodGroupUI>
    classMethodGroupUI <MethodGroupUI>    
	|
    ) (
public class ClassModel forClassDeclaratioMirror: mirror <ClassDeclarationMirror> = (
	(* public for use in Workspace *)
	|
    private classDeclaratioMirror <ClassDeclaratioMirror> = mirror.
    |
) (
public className = (
	^ classDeclarationMirror name.
)
) : (
)
public class ClassSubject onModel: model <ClassModel> = Subject onModel: model () (
public createPresenter = (
	^ ClassPresenter onSubject: self.
)
isKindOfClassSubject = (
	^ true.
)
public className = (
	^ classDeclarationMirror name.
)
public initiallyExpanded = (
	(* accessed from Presenter, must be public *)
	^ false.
)
public isMyKind: s <Subject> ^ <Boolean> = (
    ^ s isKindOfClassSubject.
)
) : (
)
public class ClassPresenter onSubject: subject <ClassSubject> = Presenter onSubject: subject (
	(* todo:  *)
) (
nestedClassesPresenters = (
	(* todo: use nestedClassesBrowsers to get this. *)
  ^ List new.
)
public isMyKind: f <Fragment> ^ <Boolean> = (
	^ f isKindOfClassPresenter.
)
public isKindOfClassPresenter = (
	^ true.
)
classPresentation = (
	^ label: subject className.
)
initiallyExpanded = (
	^ false.
)
helpText ^ <Fragment> = (

(* todo see Browsing>>ClassPresenter#helpText *)
  ^ampleforth: 'A class presenter for Simple IDE Browser. See  Browsing>>ClassPresenter#helpText'
)
public definitionORI ^ <Fragment>  = (
	(* todo return collapsed with class label, expanded with row of nested classes definitions. *)

	|classAndNestedClassesPresentation|
    (* Present directory as file, followed by contents in column under the file anme. *)
    classAndNestedClassesPresentation:: List new add: classPresentation; addAll: nestedClassesPresenters.

    (* If collapsed (default), present a localFileName as a link;
        	clicking the link opens this presenter' ~subject fullFilePath~ in a new page
            by means of
            - this FilePresenter calling ~openOnNewPage~, which:
            - creates a new ~FileSubject onModel: subject FullFilePath~,
              and calls enterSubject on this presenter subject's fullFilePath.
            Such enterSubject: newSubject thisFullFilePath causes the previous HopscotchWindow
            be replaced with the presenter on the new subject.
    	If expanded, present  ( in the current HopscotchWindow),
        dirAndContentsPresentation - a localFileName, followed by entries.
    *)
	^ collapsed: [
    		(* keep: without filePresenterMenu - link: subject localFileName action: [openOnNewPage] *)
            row: {
            	link: subject className action: [openOnNewPage].
                filler.
                (* todo dropDownMenu: [filePresenterMenu] *)
                }
            ]
    expanded: [
    		column: classAndNestedClassesPresentation
            ]
    initiallyExpanded: subject initiallyExpanded.


    (* TODO : from Browsing>>ClassPresenter#definition : add the individual methods helpSection, headingDefinition, lazySlotsPresenter, nestedClassesPresenter, etc
    classActionsPresenter:: (ClassActionsPresenter onSubject: subject) elasticity: 1.
	^column: {
        helpSection.
		headingDefinition.
		lazySlotsPresenter:: subject lazySlotsSubject presenter.
		nestedClassesPresenter:: subject nestedClassesSubject presenter. ### will be: nestedClassesGroupBrowser(slot on ClassUI) ui subject presenter
		instanceMethodsPresenter:: subject methodsSubject presenter. ### will be: methodGroupBrowser(slot on ClassUI) ui subject presenter
		classMethodsPresenter:: subject classMethodsSubject presenter.
	}
    *)

)
public definition ^ <Fragment>  = (
	(* todo return collapsed with class label, expanded with row of nested classes definitions. *)

	|classAndNestedClassesPresentation|
    (* Present directory as file, followed by contents in column under the file name. *)
    (* If collapsed (default), present a localFileName as a link;
        	clicking the link opens this presenter' ~subject fullFilePath~ in a new page
            by means of
            - this FilePresenter calling ~openOnNewPage~, which:
            - creates a new ~FileSubject onModel: subject FullFilePath~,
              and calls enterSubject on this presenter subject's fullFilePath.
            Such enterSubject: newSubject thisFullFilePath causes the previous HopscotchWindow
            be replaced with the presenter on the new subject.
    	If expanded, present  ( in the current HopscotchWindow),
        dirAndContentsPresentation - a localFileName, followed by entries.
    *)

    (*
    classAndNestedClassesPresentation:: List new add: classPresentation; addAll: nestedClassesPresenters.

	^ collapsed: [
    		(* keep: without filePresenterMenu - link: subject localFileName action: [openOnNewPage] *)
            row: {
            	link: subject className action: [openOnNewPage].
                filler.
                (* todo dropDownMenu: [filePresenterMenu] *)
                }
            ]
    expanded: [
    		column: classAndNestedClassesPresentation
            ]
    initiallyExpanded: subject initiallyExpanded.
    *)

    (* TODO : from Browsing>>ClassPresenter#definition : add the individual methods helpSection, headingDefinition, lazySlotsPresenter, nestedClassesPresenter, etc *)
    (*
    classActionsPresenter:: (ClassActionsPresenter onSubject: subject) elasticity: 1.
	^column: {
        helpSection.
		headingDefinition.
		lazySlotsPresenter:: subject lazySlotsSubject presenter.
		nestedClassesPresenter:: subject nestedClassesSubject presenter. ### will be: nestedClassesGroupBrowser(slot on ClassUI) ui subject presenter
		instanceMethodsPresenter:: subject methodsSubject presenter. ### will be: methodGroupBrowser(slot on ClassUI) ui subject presenter
		classMethodsPresenter:: subject classMethodsSubject presenter.
	}
    *)

	^column: {
        helpSection.
		headingDefinition.
                   row: {
            	link: subject className action: [openOnNewPage].
                filler.
                (* todo dropDownMenu: [filePresenterMenu] *)
                }
	}

)
headingDefinition ^ <Fragment> = (
	(* todo finish *)
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [classNameAndHierarchySummary].
	}) (* color: (Color h: 240 s: 0.05 v: 0.9) *).
)
classNameAndHierarchySummary = (
^filler.
)
expandedHeadingDefinition = (
^filler.
)
) : (
)
public class MethodGroupUI new = (
 |
    (* Only need Subject. Can get presenter and view from it *)
    subject = MethodGroupSubject onModel: (MethodGroupModel new).

(* indented browsers *)
(* none *)
 |
) (
class MethodGroupModel new = (

) (
) : (
)
class MethodGroupSubject onModel: m = Subject onModel: m (

) (
public isMyKind: s <Subject> ^ <Boolean> = (
	^ s isKindOfMethodGroupSubject.
)
public isKindOfMethodGroupSubject = (
	^ true.
)
) : (
)
class MethodGroupPresenter onSubject: s = Presenter onSubject: s (

) (
public isMyKind: f <Fragment> ^ <Boolean> = (
	^ f isKindOfMethodGroupPresenter.
)
public isKindOfMethodGroupPresenter = (
	^ true.
)
) : (
)
) : (
)
public class NestedClassGroupUI new = (
 |
    (* Only need Subject. Can get presenter and view from it *)
    subject = NestedClassGroupSubject onModel: (NestedClassGroupModel new).

(* indented browsers *)
(* none *)
 |
) (
class NestedClassGroupModel new = (

) (
) : (
)
class NestedClassGroupSubject onModel: m = Subject onModel: m (

) (
) : (
)
class NestedClassGroupPresenter onSubject: s = Presenter onSubject: s (

) (
) : (
)
) : (
)
) : (
)
public browseIDEClasses = (
      	(* Browse first 5 classes in IDE Root namespace. *)
          |browsedCount ::=  0.|
          	ide namespacing Root values do: [ :klass |
      		    browsedCount < 5 
                  	ifTrue: [
      	    			browsedCount: browsedCount + 1.
              
          	    		(* core *)
          				browseClass: klass.
              		]
          ]
      )
private browseClass: klass <Behavior | ClassDeclarationMirror> = (
	(* Need to use ClassMirror to reflect klass to see anything inside, even name. *)
      
    |
    classMirror <ClassMirror> = (ClassMirror reflecting: klass).
    classDeclarationMirror <ClassDeclarationMirror>
    nestedClassesGroup <MirrorGroup[ClassDeclarationMirror]>
    |
    classDeclarationMirror::  classMirror mixin declaration.
    classDeclarationMirror name out. 
    nestedClassesGroup:: classMirror nestedClasses.
    nestedClassesGroup do: [:nestedClassDeclarationMirror | ('   ', nestedClassDeclarationMirror name) out].
    
    ^ classDeclarationMirror.
    )
private browseClassInWindow: klass <Behavior | ClassDeclarationMirror> = (
	(* Need to use ClassMirror to reflect klass to see anything inside, even name. *)
      
    |
    classMirror <ClassMirror> = (ClassMirror reflecting: klass).
    classDeclarationMirror <ClassDeclarationMirror>
    nestedClassesGroup <MirrorGroup[ClassDeclarationMirror]>
    |
    classDeclarationMirror::  classMirror mixin declaration.
    classDeclarationMirror name out. 
    nestedClassesGroup:: classMirror nestedClasses.
    nestedClassesGroup do: [:nestedClassDeclarationMirror | ('   ', nestedClassDeclarationMirror name) out].
    
    ^ classDeclarationMirror.
    )
public browseIDEClassesInWindow = (
      	(* Browse first 5 classes in IDE Root namespace. *)
          |browsedCount ::=  0.|
          	ide namespacing Root values do: [ :klass |
      		    browsedCount < 5 
                  	ifTrue: [
      	    			browsedCount: browsedCount + 1.
              
          	    		(* core *)
          				browseClass: klass.
              		]
          ]
      )
) : (
)
