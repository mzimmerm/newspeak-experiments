Newspeak3
'Root'
class A1_SimpleIDEBrowser usingPlatform: platform <Platform> webIDE: ide <HopscotchWebIDE> 
  (* :exemplar:  A1_SimpleIDEBrowser usingPlatform: platform webIDE: ide. *)
  = (
	|
    (* imports *)
    List = platform collections List.    
    Map = platform collections Map.    
	ClassMirror = platform mirrors ClassMirror.

	Presenter = platform hopscotch Presenter.
    Subject = platform hopscotch Subject.
    
	ProgrammingPresenter = ide browsing ProgrammingPresenter.
    ProgrammingSubject =  ide browsing ProgrammingSubject.

	Exception = platform kernel Exception.
    Color = platform graphics Color.
    
    (* slots *)
    ide = ide.
    classUIs <List[ClassUI]> (* todo : should this be ClassGroup? *)
    
    (* Style *)    
	styleHeaderPadRight <Float> = 0.0.
    styleButtonSize <Float> = 30.
    
	|
  ) (
public class ClassUI forClassDefinedBy: classOrClassDeclarationMirror <Behavior|ClassDeclarationMirror> = (
  	|
    (* Class is also Behavior *)
    (* public for accesibility to pass to nested ClassModel factory *)
    public classDeclarationMirror = classOrClassDeclarationMirror isKindOfClass 
    	ifTrue: [(ClassMirror reflecting: classOrClassDeclarationMirror) mixin declaration]
        ifFalse: [
        	classOrClassMirror isKindOfClassDeclarationMirror
            	ifTrue: [classOrClassDeclarationMirror]
                ifFalse: [break. Exception signal: 'Perhaps trying to pass aClassMirror? Pass aClassMirror declaration <ClassDeclarationMirror> instead.']
        ].
  
    (* todo Only need Subject. Can get presenter and view from it *)
    subject = ClassSubject onClassModel: (ClassModel forClassDeclarationMirror: classDeclarationMirror).

	(* members used by multiple models in UI and it's nested classes *)
    (* todo-done private classDeclarationMirror = classMirror mixin declaration. *)
    
    (* instanceSide returns MixinMirror, which has API similar to ClassMirror, can get slots, nestedClasses, methods from it. TODO: WHY NOT classSide?? *)
    public nestedClassesGroup <MirrorGroup[ClassDeclarationMirror]> =  classDeclarationMirror instanceSide nestedClasses.
    public nestedClassDeclarationMirrors ::= nestedClassesGroup do: [:nestedClassDeclarationMirror | nestedClassDeclarationMirror].

    (* indented UIs *)
	factoryUI <FactoryUI> (* todo : this seems replaced with headingDefinition *)
    (* todo: finish: nestedClassesUIs <List[ClassUI]> ::= nestedClassDeclarationMirrors collect: [:nestedClassDeclarationMirror | ClassUI forClass: nestedClassDeclarationMirror klass]. *)
    nestedClassGroupUI <NestedClassGroupUI>
    instanceMethodGroupUI <MethodGroupUI>
    classMethodGroupUI <MethodGroupUI>    
	|
    ) (
public class ClassModel forClassDeclarationMirror: cdm <ClassDeclarationMirror> = (
	(* public for use in Workspace *)
	|
    private classDeclarationMirror <ClassDeclaratioMirror> = cdm.
    |
    
    (* Browsing version
		public class ClassModel declaration: cd <ClassDeclarationMirror> exemplar: e <ObjectMirror | Nil> enclosing: o <ObjectMirror | Nil>  
		= (
		|
		public klass <ClassDeclarationMirror> = cd.
        	public exemplar <ObjectMirror | Nil> ::= e.
        	enclosing_slot <ObjectMirror | Nil> ::= e isNil ifTrue: [o].
		|
    	assert: [cd isKindOfClassDeclarationMirror] message: 'ClassModel built upon another ClassModel?!'.
		)   
	*)
) (
public name = (
	^ classDeclarationMirror name.
)
public classMirror ^ <ClassDeclarationMirror> = (
  ^classDeclarationMirror
)
public isKindOfClassModel ^ <Boolean>  = (
  ^true
)
public = other <Object> ^ <Boolean> = (
	other isKindOfClassModel ifFalse: [^false].
    ^classDeclarationMirror = other classDeclarationMirror (* and: [exemplar = other exemplar]. *).
    )
public hash ^ <Integer> = (
	^ classDeclarationMirror hash (* bitXor: exemplar hash *)
)
) : (
)
public class ClassSubject onClassModel: model <ClassModel> = ProgrammingSubject onModel: model (
	(* Browsing>>ClassSubject has this: .
	public class ClassSubject onClassModel: m <ClassModel> = ProgrammingSubject onModel: m (
	  | 
	  public exemplar <ObjectMirror> ::= classModel exemplar.
	  lazySlotsSubject_slot  <LazySlotGroupSubject>  
      nestedClassesSubject_slot  <NestedClassGroupSubject>
	  methodsSubject_slot  <MethodGroupSubject>
	  classMethodsSubject_slot  <MethodGroupSubject>
	  objectSubject_slot <ObjectSubject>
	  |
	)
	*)
) (
public createPresenter = (
	^ ClassPresenter onSubject: self.
)
isKindOfClassSubject = (
	^ true.
)
public initiallyExpanded = (
	(* accessed from Presenter, must be public *)
	^ false.
)
public isMyKind: s <Subject> ^ <Boolean> = (
    ^ s isKindOfClassSubject.
)
public name = (
	^ model name.
)
public title = (
	^name
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model classMirror
)
public enclosingClassSubjects ^ <List[ClassSubject]> = (
	(* Browsing>>ClassSubject has:.
	public enclosingClassSubjects ^ <List[ClassSubject]> = (
		| them = List new. c |
		c:: classMirror.
		[c isNil] whileFalse: [them add: (ClassSubject onDeclaration: c). c:: c enclosingClass].
		^them
	)    
    *)
	| them = List new. c |
	c:: classMirror.
	(* [c isNil] whileFalse: [them add: (ClassSubject onDeclaration: c). c:: c enclosingClass]. *)
	[c isNil] whileFalse: [them add: (ClassSubject onDeclaration: c). c:: c enclosingClass].
	^them
)
) : (
public onDeclaration: cd <ClassDeclarationMirror> ^ <Instance> = (
  (* Browsing>>ClassSubject has: ^onClassModel: (ClassModel declaration: cd exemplar: nil) *)
  ^onClassModel: (ClassModel forClassDeclarationMirror: cd (* exemplar: nil *) )
)
)
public class ClassPresenter onSubject: subject <ClassSubject> = ProgrammingPresenter onSubject: subject (
	(* Browsing>>ClassPresenter contains: .
    class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
	  |
	  public lazySlotsPresenter <LazySlotGroupPresenter>  
	  public nestedClassesPresenter <NestedClassGroupPresenter>
	  public instanceMethodsPresenter <MethodGroupPresenter>
	  public classMethodsPresenter <MethodGroupPresenter>
	  classActionsPresenter <ClassActionsPresenter>
	  |
	)
    *)
	|
	classActionsPresenter <ClassActionsPresenter> = smallBlank. (* todo *)
    |
) (
nestedClassesPresenters = (
	(* todo: use nestedClassesBrowsers to get this. *)
  ^ List new.
)
public isMyKind: f <Fragment> ^ <Boolean> = (
	^ f isKindOfClassPresenter.
)
public isKindOfClassPresenter = (
	^ true.
)
classPresentation = (
	^ label: subject className.
)
initiallyExpanded = (
	^ false.
)
public definitionORI ^ <Fragment>  = (
	(* todo return collapsed with class label, expanded with row of nested classes definitions. *)

	|classAndNestedClassesPresentation|
    (* Present directory as file, followed by contents in column under the file anme. *)
    classAndNestedClassesPresentation:: List new add: classPresentation; addAll: nestedClassesPresenters.

    (* If collapsed (default), present a localFileName as a link;
        	clicking the link opens this presenter' ~subject fullFilePath~ in a new page
            by means of
            - this FilePresenter calling ~openOnNewPage~, which:
            - creates a new ~FileSubject onModel: subject FullFilePath~,
              and calls enterSubject on this presenter subject's fullFilePath.
            Such enterSubject: newSubject thisFullFilePath causes the previous HopscotchWindow
            be replaced with the presenter on the new subject.
    	If expanded, present  ( in the current HopscotchWindow),
        dirAndContentsPresentation - a localFileName, followed by entries.
    *)
	^ collapsed: [
    		(* keep: without filePresenterMenu - link: subject localFileName action: [openOnNewPage] *)
            row: {
            	link: subject className action: [openOnNewPage].
                filler.
                (* todo dropDownMenu: [filePresenterMenu] *)
                }
            ]
    expanded: [
    		column: classAndNestedClassesPresentation
            ]
    initiallyExpanded: subject initiallyExpanded.


    (* TODO : from Browsing>>ClassPresenter#definition : add the individual methods helpSection, headingDefinition, lazySlotsPresenter, nestedClassesPresenter, etc
    classActionsPresenter:: (ClassActionsPresenter onSubject: subject) elasticity: 1.
	^column: {
        helpSection.
		headingDefinition.
		lazySlotsPresenter:: subject lazySlotsSubject presenter.
		nestedClassesPresenter:: subject nestedClassesSubject presenter. ### will be: nestedClassesGroupBrowser(slot on ClassUI) ui subject presenter
		instanceMethodsPresenter:: subject methodsSubject presenter. ### will be: methodGroupBrowser(slot on ClassUI) ui subject presenter
		classMethodsPresenter:: subject classMethodsSubject presenter.
	}
    *)

)
expandedHeadingDefinition = (
^filler.
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classNameAndContainmentDefinition ^ <Fragment> = (
	^column: {
		classNameAndHierarchySummary.
		preambleLine.
		label: subject classCommentSummary.
	}
)
classNameAndHierarchySummary = (
	| parts <List[Fragment]> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		row: {
			smallBlank.
			(image: ide images classIcon)
                 height: styleButtonSize.
			smallBlank.
			row: parts.
			filler.
            classActionsPresenter.
			smallBlank.
			itemReferencesButtonWithAction: [browseSelector: subject name].
			smallBlank.
			saveButtonWithAction: [respondToSave].
			smallBlank.
			refreshButton.			
			smallBlank.
            helpButton.
			smallBlank.
			dropDownMenu: [classActionsMenu].
		}
	}
)
classActionsMenu = (
	^menuWithLabelsAndActions: {
	 	{'Save to File'. [respondToSave]}.
		 #separator.
		{'Inspect Mirror'. [inspectObject: subject classMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
		#separator.
		{'Delete'. [respondToDelete]}.
	}
)
headingDefinition ^ <Fragment> = (
	(* todo finish *)
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [classNameAndHierarchySummary].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
public definition ^ <Fragment>  = (
	(* todo return collapsed with class label, expanded with row of nested classes definitions. *)

	|classAndNestedClassesPresentation|
    (* Present directory as file, followed by contents in column under the file name. *)
    (* If collapsed (default), present a localFileName as a link;
        	clicking the link opens this presenter' ~subject fullFilePath~ in a new page
            by means of
            - this FilePresenter calling ~openOnNewPage~, which:
            - creates a new ~FileSubject onModel: subject FullFilePath~,
              and calls enterSubject on this presenter subject's fullFilePath.
            Such enterSubject: newSubject thisFullFilePath causes the previous HopscotchWindow
            be replaced with the presenter on the new subject.
    	If expanded, present  ( in the current HopscotchWindow),
        dirAndContentsPresentation - a localFileName, followed by entries.
    *)

    (*
    classAndNestedClassesPresentation:: List new add: classPresentation; addAll: nestedClassesPresenters.

	^ collapsed: [
    		(* keep: without filePresenterMenu - link: subject localFileName action: [openOnNewPage] *)
            row: {
            	link: subject className action: [openOnNewPage].
                filler.
                (* todo dropDownMenu: [filePresenterMenu] *)
                }
            ]
    expanded: [
    		column: classAndNestedClassesPresentation
            ]
    initiallyExpanded: subject initiallyExpanded.
    *)

    (* Browsing>>ClassPresenter#definition : add the individual methods helpSection, headingDefinition, lazySlotsPresenter, nestedClassesPresenter, etc *)
    (*
    classActionsPresenter:: (ClassActionsPresenter onSubject: subject) elasticity: 1.
	^column: {
        helpSection.
		headingDefinition.
		lazySlotsPresenter:: subject lazySlotsSubject presenter.
		nestedClassesPresenter:: subject nestedClassesSubject presenter. ### will be: nestedClassesGroupBrowser(slot on ClassUI) ui subject presenter
		instanceMethodsPresenter:: subject methodsSubject presenter. ### will be: methodGroupBrowser(slot on ClassUI) ui subject presenter
		classMethodsPresenter:: subject classMethodsSubject presenter.
	}
    *)

	^column: {
        helpSection.
		headingDefinition.
        (*
        row: {
            	link: subject className action: [openOnNewPage].
                filler.
                dropDownMenu: [filePresenterMenu]
                }
        *)        
	}

)
classNameAndHierarchySummaryORI  = (
	| parts <List[Fragment]> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		row: {
			smallBlank.
			(image: ide images classIcon)
                 height: styleButtonSize.
			smallBlank.
			row: parts.
			filler.
            classActionsPresenter.
			smallBlank.
			itemReferencesButtonWithAction: [browseSelector: subject name].
			smallBlank.
			saveButtonWithAction: [respondToSave].
			smallBlank.
			refreshButton.			
			smallBlank.
            helpButton.
			smallBlank.
			dropDownMenu: [classActionsMenu].
		}
	}
)
helpText ^ <Fragment> = (

(* todo see Browsing>>ClassPresenter#helpText *)
	|mapping = Map new.|
    (*
    mapping
    at: #classTestActions put: classActions testActions;  
    at: #classDeployAction put: classActions deployAction;
    at: #classEditDeploymentsAction put: classActions editDeploymentsAction;
    at: #classRunAppAction put: classActions runAppAction;    
    at: #hopscotchClassActionsMenuButton put: (dropDownMenu: [classActionsMenu]);
    at: #hopscotchClassReferencesButton put: (itemReferencesButtonWithAction: [browseSelector: subject name]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton;
    at: #hopscotchSaveButton put: (saveButtonWithAction: [respondToSave]).
    *)
    
  ^ampleforth: 'A class presenter for Simple IDE Browser. See  Browsing>>ClassPresenter#helpText' mapping: mapping
)
) : (
)
public class MethodGroupUI new = (
 |
    (* Only need Subject. Can get presenter and view from it *)
    subject = MethodGroupSubject onModel: (MethodGroupModel new).

(* indented browsers *)
(* none *)
 |
) (
class MethodGroupModel new = (

) (
) : (
)
class MethodGroupSubject onModel: m = Subject onModel: m (

) (
public isMyKind: s <Subject> ^ <Boolean> = (
	^ s isKindOfMethodGroupSubject.
)
public isKindOfMethodGroupSubject = (
	^ true.
)
) : (
)
class MethodGroupPresenter onSubject: s = Presenter onSubject: s (

) (
public isMyKind: f <Fragment> ^ <Boolean> = (
	^ f isKindOfMethodGroupPresenter.
)
public isKindOfMethodGroupPresenter = (
	^ true.
)
) : (
)
) : (
)
public class NestedClassGroupUI new = (
 |
    (* Only need Subject. Can get presenter and view from it *)
    subject = NestedClassGroupSubject onModel: (NestedClassGroupModel new).

(* indented browsers *)
(* none *)
 |
) (
class NestedClassGroupModel new = (

) (
) : (
)
class NestedClassGroupSubject onModel: m = Subject onModel: m (

) (
) : (
)
class NestedClassGroupPresenter onSubject: s = Presenter onSubject: s (

) (
) : (
)
) : (
)
) : (
)
public browseIDEClasses = (
      	(* Browse first 5 classes in IDE Root namespace. *)
          |browsedCount ::=  0.|
          	ide namespacing Root values do: [ :klass |
      		    browsedCount < 5 
                  	ifTrue: [
      	    			browsedCount: browsedCount + 1.
              
          	    		(* core *)
          				browseClass: klass.
              		]
          ]
      )
private browseClass: klass <Behavior | ClassDeclarationMirror> = (      
    |
	classOrClassDeclarationMirror = klass.
	classUI = self ClassUI forClassDefinedBy: classOrClassDeclarationMirror.
    classDeclarationMirror = classUI classDeclarationMirror.
    nestedClassesGroup = classUI nestedClassesGroup.
    |
    classDeclarationMirror name out. 
    nestedClassesGroup do: [:nestedClassDeclarationMirror | ('   ', nestedClassDeclarationMirror name) out].
    
   )
) : (
)
